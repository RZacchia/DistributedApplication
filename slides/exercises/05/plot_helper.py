import re
import matplotlib.pyplot as plt
# Generated by ChatGPT
LOG_FILE = "scaling.log"  # change this if your log file has a different name/path

def parse_log_hpa(filepath):
    replicas = []
    cpu_util = []  # current CPU utilization (before the / in "40%/80%")

    with open(filepath, "r") as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("NAME"):
                # Skip empty lines and header lines
                continue

            parts = line.split()

            # Expected example split:
            # ['task05', 'Deployment/task05', 'cpu:', '40%/80%', '1', '5', '5', '41h']

            # Find the token with "%/" which contains "40%/80%"
            cpu_field = None
            for p in parts:
                if "%/" in p:
                    cpu_field = p
                    break

            if cpu_field is None:
                # If nothing matched, skip this line
                continue

            # Extract current CPU utilization (before slash)
            # "40%/80%" -> "40"
            current_cpu_str = cpu_field.split("/")[0].rstrip("%")
            try:
                current_cpu = float(current_cpu_str)
            except ValueError:
                # If parsing fails, skip this line
                continue

            # Replicas is the second-to-last column (before AGE)
            # e.g. ['task05', 'Deployment/task05', 'cpu:', '40%/80%', '1', '5', '5', '41h']
            #                                                             ^  ^
            #                                                          repl  age
            try:
                repl = int(parts[-2])
            except ValueError:
                continue

            cpu_util.append(current_cpu)
            replicas.append(repl)

    return replicas, cpu_util

def plot_hpa_metrics(replicas, cpu_util):
    if not replicas or not cpu_util:
        print("No data to plot.")
        return

    # Each record is 5 seconds apart
    timesteps = [i * 5 for i in range(len(replicas))]

    fig, ax1 = plt.subplots()

    # --- AREA CHART for Replicas ---
    ax1.fill_between(timesteps, replicas, step="mid", alpha=0.4, label="Replicas")
    ax1.plot(timesteps, replicas, alpha=0.8, linewidth=2)
    ax1.set_xlabel("Time (seconds)")
    ax1.set_ylabel("Replicas")

    # --- LINE CHART for CPU Util ---
    ax2 = ax1.twinx()
    ax2.fill_between(timesteps, cpu_util, step="mid", color='red', alpha=0.4, label="CPU Utilization (%)")
    ax2.plot(timesteps, cpu_util, color='red', alpha=0.8, linewidth=2)
    ax2.set_ylabel("CPU Utilization (%)")

    # Merge legends from both axes
    lines_1, labels_1 = ax1.get_legend_handles_labels()
    lines_2, labels_2 = ax2.get_legend_handles_labels()
    ax1.legend(lines_1 + lines_2, labels_1 + labels_2, loc="upper right")

    plt.title("Replicas and CPU Utilization over Time (5s intervals)")
    plt.tight_layout()
    plt.show()


def parse_cpu_levels_and_values(filepath):
    """
    Parse repeating blocks like:

    NAME     MODE       CPU   MEM     PROVIDED   AGE
    task05   Recreate   25m   250Mi   True       13m
    NAME                      CPU(cores)   MEMORY(bytes)
    task05-74b7bb74bb-bn8gx   1m           37Mi

    We collect:
      - CPU level: '25m'  (2nd line, 3rd column)
      - CPU value: '1m'   (4th line, 2nd column)
    Returned as integer millicores: 25, 1, ...
    """
    cpu_levels = []  # e.g. 25 (from 25m)
    cpu_values = []  # e.g. 1 (from 1m)

    with open(filepath, "r") as f:
        lines = f.readlines()

    i = 0
    n = len(lines)

    while i < n:
        line = lines[i].rstrip("\n")

        # Header: NAME MODE CPU MEM ...
        if re.search(r"\bNAME\b", line) and re.search(r"\bMODE\b", line):
            # Next non-empty line is the row with CPU level
            j = i + 1
            while j < n and not lines[j].strip():
                j += 1
            if j < n:
                parts = lines[j].split()
                # Expected: NAME MODE CPU MEM PROVIDED AGE
                # Indices:   0    1    2   3   4        5
                if len(parts) >= 3:
                    cpu_lvl_str = parts[2]  # e.g. "25m"
                    cpu_lvl_val = parse_millicores(cpu_lvl_str)
                    if cpu_lvl_val is not None:
                        cpu_levels.append(cpu_lvl_val)
            i = j
            continue

        # Header: NAME ... CPU(cores) MEMORY(bytes)
        if "CPU(cores)" in line:
            j = i + 1
            while j < n and not lines[j].strip():
                j += 1
            if j < n:
                parts = lines[j].split()
                # Expected: PODNAME CPU(cores) MEMORY(bytes)
                # Indices:  0       1          2
                if len(parts) >= 2:
                    cpu_val_str = parts[1]  # e.g. "1m"
                    cpu_val_val = parse_millicores(cpu_val_str)
                    if cpu_val_val is not None:
                        cpu_values.append(cpu_val_val)
            i = j
            continue

        i += 1

    return cpu_levels, cpu_values


def parse_millicores(s):
    """
    Convert CPU strings like '25m', '100m' into integer millicores.
    Returns None on failure.
    """
    s = s.strip()
    if s.endswith("m"):
        num = s[:-1]
        try:
            return int(num)
        except ValueError:
            return None
    # If there's no 'm', you could decide what to do.
    # For safety, return None here.
    return None

def plot_cpu_levels(cpu_levels, cpu_values):
    if not cpu_levels or not cpu_values:
        print("No CPU-level data to plot.")
        return

    # Use the shorter length if they don't perfectly match
    length = min(len(cpu_levels), len(cpu_values))
    cpu_levels = cpu_levels[:length]
    cpu_values = cpu_values[:length]

    timesteps = [i * 5 for i in range(length)]

    plt.figure()
    plt.fill_between(timesteps, cpu_levels, step="mid", alpha=0.4)
    plt.plot(timesteps, cpu_levels, label="Target CPU (m)", linewidth=2)
    plt.fill_between(timesteps, cpu_values, step="mid", alpha=0.4, color="red")
    plt.plot(timesteps, cpu_values, label="Pod CPU (m)", linewidth=2, color="red")
    plt.xlabel("Time (seconds)")
    plt.ylabel("CPU (millicores)")
    plt.title("Target CPU vs Pod CPU over Time (5s intervals)")
    plt.legend()
    plt.tight_layout()
    plt.show()


def main():
    # replicas, cpu_util = parse_log_hpa(LOG_FILE)
    # plot_hpa_metrics(replicas, cpu_util)
    levels, values = parse_cpu_levels_and_values(LOG_FILE)
    plot_cpu_levels(levels, values)

if __name__ == "__main__":
    main()
